\begin{abstract}
    Technical debt (TD) is a term that refers to a collection of design and implementation constructs that are not sustainable in the long term but meet the needs of the stakeholders in the short term.
    The presence of TD reduces the ability of software developers and architects to easily comprehend, evolve, and maintain a software system.
    Eventually, an excessive amount of TD may result in the software project's failure due to the excessive costs to keep maintaining it.

    Over the years, researchers have refined the definition of TD and identified the different forms that TD can manifest in.
    The main distinction between these forms is based on the type of artefact and level of abstraction that TD affects.
    Architectural TD (ATD) is a type of TD that, as the name suggests, represents the TD that concerns the architecture of a system.
   
    Architectural smells are a notoriously detrimental form of ATD that refer to violations of well known design principles that result in undesired dependencies, overblown size, and excessive coupling.
    Architectural smells have a negative influence on the maintainability and evolvability of a system, making it harder to apply changes and add new functionality.
    Researchers have identified, described, and categorised several types of architectural smells over the past years.
    Subsequently, several research tools were born to automatically detect such smells starting from the source artefacts of a system.

    From the practitioners' point of view, in order to properly be able to manage the technical debt generated by architectural smells, identification alone is not enough.
    To properly address the threat posed by architectural smells to the maintainability of a system, practitioners require support for the prioritisation, quantification, repayment, and monitoring activities as well.
    Unfortunately, the literature on the topic is incomplete, and the tool support for these specific activities is lacking.
    
    \textbf{The main focus of this thesis is to improve the support provided to practitioners that need to manage architectural smells}. In particular, it focuses on providing support for practitioners that need to \emph{quantify} the amount of TD generated by each architectural smell, \emph{monitor} the trend of the TD over time, and \emph{identify the prioritisation strategies} available to better repay the TD incurred.

    There exist several types of architectural smells, therefore, to narrow down the scope of the investigation, we decide to focus on the four types that are the most prominent in the literature: Cyclic Dependency (CD), Hublike Dependency (HL), Unstable Dependency (UD), and God Component (GC).
    
    To improve the support of architectural smells management, we first opted to analyse the evolution of individual architectural smell instances in long-lived, open-source systems by mining their software repositories.
    This allowed us to investigate prioritisation opportunities based on the history of architectural smells.
    The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system.
    Based on these differences, we extrapolated that the refactoring of HL smells should be prioritised over CD smells and that many CD instances should have a low priority as they are likely to be organically removed in the upcoming releases.

    These findings however are based on mining software repositories, thus they can only tell half the story.
    To investigate the other half, we decided to ask 21 software practitioners their opinion on architectural smells and what smells they think are more disruptive for the maintainability of a system.
    The findings show that practitioners think of certain smells as more impactful than others.
    One above all is the GC smell, that is perceived more detrimental than others, although the opinion on the HL smell was quite similar.

    From talking to practitioners, we also learned that they struggle to keep track of architectural smells, how they are introduced, and whether multiple instances overlap. 
    This motivated us to further investigate how architectural smells are introduced, and to broaden the scope, also how they co-occur, and evolve over time in an industrial context.
    We set up an industrial case study to investigate these aspects in the context of a large multinational company that works in C/C++, and verify whether the findings of the previous studies (that were all based on Java systems) apply to this context as well.
    The results show that CD smells, although they are not very persistent within the system, are precursors to other smell types.
    Therefore, CD instances can be used as a red flag that notifies practitioners that a component might present a more severe architectural smell soon. Indeed, 94\% of HL smells, were also part of a cycle.
    
    As part of the same investigation, we also elicited the opinion of software engineers and architects, who mentioned that the most problematic aspect of architectural smells are change ripple effects, that are unpredictable.
    This motivated us to investigate the relation between architectural smells and source code changes.
    After analysing over 30 open-source Java systems, we ran a series of statistical tests to determine whether source code changes were more frequent, and larger in size, in components that were affected by smells than in non-affected components.
    The findings show that this is indeed the case, and that all four architectural smells correlate with higher frequency of change of the affected part. 
    Interestingly, after talking to practitioners in the previous study we expected UD to be the smell with the highest correlation with changes. This turned out, however, not to be the case as we observed over 10\% higher change rate for the HL smell than for the UD smell.
    This means that prioritising the refactoring of HL instances over the other smell types is a more advantageous approach for practitioners.

    The answers collected up until this point provided valuable insights on how architectural smells are perceived by practitioners, how they get introduced, how they co-occur, and how they correlate with the changes done in the system.
    These results allowed us to extrapolate valuable information on what the best strategies are to prioritise smell instances and what makes one instance more severe than the other.
    Therefore, using the acquired knowledge, we created a machine learning model that ranks architectural smells based on their severity which performs rather well (97\% of instances are ranked above a less severe smell).
    This model makes it easier for practitioners to prioritise architectural smells, especially in very large systems where hundreds of instances can be detected.
    Additionally, using this model, we designed an approach to quantify the amount of technical debt generated by the architectural smells detected in a system.
    The validation of the model shows that in 71\% of the cases, practitioners agreed that the estimations provided were representative of the effort necessary to refactor the smell.

    Finally, we also learned from practitioners that TD prioritisation (and consequently its repayment) is influenced, not only by other TD items, but also by other quality attributes (e.g. availability), thus forcing practitioners to sacrifice maintainability constantly.
    We proceeded to investigate this aspect and talked to 21 practitioners and learned that practitioners often prioritise run-time qualities over design-time qualities, and do so mostly implicitly, due to lack of monitoring tools. 
    
\end{abstract}

%Enabling technical debt repayment for architectural smells